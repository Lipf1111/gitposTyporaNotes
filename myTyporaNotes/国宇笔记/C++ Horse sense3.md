#### Q1 C++中不能重载的运算符

C++中绝大部分的运算符允许重载。

不能重载的运算符只有5个：

（1）. （成员访问运算符）。

（2）.* （成员指针访问运算符）。

（3）∷（域运算符）。

（4）sizeof（长度运算符）。

（5）?: （条件运算符）。

**重载操作符的限制：**

1、重载不能改变该运算符用于内置类型时的涵义，程序员不能改变运算符+用于两个int型时的含义。

2、运算符函数的参数至少有一个必须是类的对象或者类的对象的引用。这种规定可以防止程序员运用运算符改变内置类型的涵义。

3、重载不能改变运算符的优先级。

4、重载不能改变运算符的结合律。

5、重载不能改变运算符操作数的个数。比如+需要两个操作数，则重载的+也必须要有两个操作数。

 **使用规则**:(类的具体对象.\*类的函数指针)( ) 

```c++
STUDENT student;
int (STUDENT::*p)() = &STUDENT::fun;
(student.*p)();
```

 **使用规则**:(类的具体对象的指针->\*类的函数指针)( ) 

```c++
STUDENT student;
STUDENT *pt = &student;
int (STUDENT::*p)() = &STUDENT::fun;
(pt->*p)();
```

#### Q2 死锁

死锁产生的四个必要条件

- **互斥条件：**资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。
- **不可剥夺条件：**进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
- **请求和保持条件：**进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
- **循环等待条件：**在发生死锁时必然存在一个进程等待队列{P1,P2,…,Pn},其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路，环路中每一个进程所占有的资源同时被另一个申请，也就是前一个进程占有后一个进程所深情地资源。
  以上给出了导致死锁的四个必要条件，只要系统发生死锁则以上四个条件至少有一个成立。事实上**循环等待**的成立蕴含了前三个条件的成立，似乎没有必要列出然而考虑这些条件对死锁的预防是有利的，因为可以通过破坏四个条件中的任何一个来预防死锁的发生。

死锁预防

我们可以通过破坏死锁产生的4个必要条件来 预防死锁，由于资源互斥是资源使用的固有特性是无法改变的。

1. **破坏“不可剥夺”条件：**一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到 系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行。
2. **破坏”请求与保持条件“：**第一种方法静态分配即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配即每个进程在申请所需要的资源时他本身不占用系统资源。
3. **破坏“循环等待”条件：**采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。

#### Q3  端口号

非root帐号不能打开1024以下的端口号。 

#### Q4 memset函数为二维数组初始化

```cpp
int* a;  a = new int[10]; 
```

sizeof(a) 只会返回出来指针的大小，所以我们只能自己计算这个数组的长度,这里应当是sizeof(int) * 10, 因为数组里面有10个int
**所以应该，memset(a, 0, sizeof(int)\*10);//将a数组初始化为0**

```cpp
int **p;//开一个n*m的数组
p = new int*[n];
for (int i = 0; i < n; i++){
    p[i] = new int[m + 1];
    memset(p[i], 0, sizeof(int)*m);//p赋初值为0,sizeof一个指针返回的是指针大小，所以还是sizeof(int)
}
for (int i = 0; i < n; i++)//释放p
    delete[] p[i];
delete[] p;
```

memset(p, 0, sizeof(int)*m*n);//因为是p相当于一个指向一个一维数组的***\*指针\****，首先格式就不对

memset(p, 0, sizeof(p)*m*n);//也不对，因为我们要的是真正储存数据的空间，而不是指针

#### Q5 数组长度

```c++
int array[] = { 1,4,5,2,8,4 };
cout << sizeof(array)<< endl;//24
cout << sizeof(array) / sizeof(int)<<endl;//6
//不能array.size();类
//不能strlen(array)字符串
```

#### Q6 

```c++
#define Max(a,b) (a>b?a:b);
int  a = 5;
cout << Max(a++, 0);//6
/*
cout << Max(++a, 0);//7
*/
```

#### Q7 

```c++
#include "bits_stdc++.h"
using namespace std;
class A {
public:
	int a[10];
};
class B:public A {//#1    class B:virtual public A
public:
	B() {}
	~B() {}
};
class C :public A {//#1   class C:virtual public A
public:
	C() {}
	~C() {}
};
class D :public B , public C {
public:
	D() {}
	~D() {}
};
int main() {
	D test;
	cout << sizeof(test);//80 
    return 0;
}//当为#1时输出48，那个8应该是两个指针
```

#### Q8

```c++
//类的默认权限为Private,结构体的默认权限为Public
//类的默认继承权限为private,结构体的默认继承权限为Public
class A {
	int a;
protected:
    int b;
public:
    int c;
    A() { a = b = c = 1; }
};
//类B以公有方式从基类A继承
class B : public A {
public:
    int d;
    B() {//a=2;  //错误，不能访问基类中的私有成员
        b = 2;   //正确，可以在类中访问基类中的受保护成员，但类的对象不能访问，基类中的受保护成员b在类B中仍然是受保护成员
        c = d = 2;
    }
}; //基类中的公有成员c在类B中仍然是公有成员
//类C以受保护和私有方式从基类A继承。
class C : protected A {
public:
    int e;
    C() {//a=3;  //错误，不能访问基类中的私有成员
        b = c = e = 3;
    }
};//这里基类受保护成员b和公有成员c都成为类C中的受保护成员。

class D : private A {
public:
    D()
    { b = c = 4; }
};//基类中的公有和受保护成员都成为了类D中的私有成员。
//验证受保护和私有方式继承的访问权限。
class C1 : public C {
public:
    C1() { b = c = e = 4; }
};//正确;类A中的成员b和c在类C中是以受保护方式被继承的，b和c都成为了类C中的受保护成员。
class D1 : public D {
public:
    D1() {//b=5; //错误，在A中受保护的成员b在类D中是以私有方式继承的，这样b就成为了类D中的私有成员，所以无法访问。
          //c=5; //错误，在A中公有的成员c在类D中是以私有方式继承的，这样c就成为了类D中的私有成员，所以无法访问。
         }
};
int main(){
    A m1;
    B m2;
    C m3;
    D m4;
	//cout<<m1.b<<m2.b<<m3.b<<m4.b<<endl;   //错误；不能用类的对象访问受保护的成员，只有在类中才能访问。
    cout << m1.c <<endl;
    cout << m2.c <<endl;
    //cout<<m3.c<<endl;    //错误，类C是以受保护的方式从A继承的，基类中的变量c在类C中就是受保护的，所以类的对象不能访问
    //cout<<m4.c<<endl;    //错误，类C是以私有的方式从A继承的，基类中的变量c在类C中就是私有的，所以类的对象不能访
}
```

#### Q9 友元函数是否能继承

```c++
#include <iostream> 
using namespace   std;
class B;
class A{
	int a;
public:
	A(int x = 0) { a = x; }
	friend class B;
};
class B{
	int b;
public:
	void fun(A& ob) { cout << ob.a << endl; }
};
class C :public B{
public:
	//void fun2(A& ob){ cout <<ob.a <<endl;}   //派生类新加的函数却不能访问A，此句会报错
    //void fun(A& ob){ cout <<ob.a <<endl;}//报错，a无法访问
};
int main(){
	A a(55);
	C c;
	c.fun(a); //C是B的派生类   通过基类B的函数fun仍然可以访问 
    return 0;
}
//友元函数不能继承
```

#### Q10 函参类型

```c++
#include <iostream> 
using namespace   std;
void test(int a, int b = 2, char ch = 's') {
	cout << a << endl;
	cout << b << endl;
	cout <<ch << endl;
}
int  main(){
	test('*');//42 2 s
    test('*',4,52);//42	4	4
    test('*',4,5);//42	4	口  //cout <<(int)ch << endl;则5
    test('0');//48
    test('00');//12336   其二进制为0100 0000 0100 0000即0 0的anscii;最多有4个0,因其达到32位，当为5个0时报错。
	return 0;
}
```

#### Q11 判断整数能够整除8

判断一个数是否能够被8整除，只需要判断这个数的后三位是否能够整除8即可。

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int ff(char a, char b, char c) {//判断三个数字组成的数能否被8整除
	int s[7];
	s[1] = (a - '0') * 100 + (b - '0') * 10 + (c - '0');
	s[2] = (a - '0') * 100 + (c - '0') * 10 + (b - '0');
	s[3] = (b - '0') * 100 + (c - '0') * 10 + (a - '0');
	s[4] = (b - '0') * 100 + (a - '0') * 10 + (c - '0');
	s[5] = (c - '0') * 100 + (a - '0') * 10 + (b - '0');
	s[6] = (c - '0') * 100 + (b - '0') * 10 + (a - '0');
	for (int i = 1; i <= 6; i++) {
		//cout<<s[i]<<endl;
		if (s[i] % 8 == 0) return 1;
	}
	return 0;
}
char s[10005];
int main(){
	while (scanf("%s", s) != EOF) {
		int len = strlen(s);
		int ok = 0;
		if (len == 1) {
			if ((s[0] - '0') % 8 == 0) ok = 1;
		}
		else if (len == 2) {
			if (((s[0] - '0') * 10 + (s[1] - '0')) % 8 == 0) ok = 1;
			if (((s[1] - '0') * 10 + (s[0] - '0')) % 8 == 0) ok = 1;
		}
		else {
			for (int i = 0; i < len; i++) {
				if (ff(s[i], s[(i + 1) % len], s[(i + 2) % len])) {
					ok = 1; break;
				}
			}
		}
		if (ok) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```

#### Q12 整除特例

```c++
#include<iostream>
using namespace std;
int main(){
	for (int i = 10; i < 100;++i) {
		cout <<i<<":"<< (i&7)<<endl ;
	}
	return 0;
}
//此为测试是否被8整除，(i) & 7的结果为余数，则为0表示整除
//另，可测试是否被16整除，(i) & 15，只要&的数为全1即可
//可知可测试2,(i) & 1，奇数余1,
//4，(i) & 3
```

#### Q13 typeid

**typeid是操作符，不是函数**。与sizeof类似

typeid操作符的返回结果是名为type_info的标准库类型的对象的引用（在头文件typeinfo中定义 )

​		如果表达式的类型是类类型且至少包含有一个虚函数，则typeid操作符返回表达式的动态类型，需要在运行时计算；否则，typeid操作符返回表达式的静态类型，在编译时就可以计算。 

​		ISO C++标准并没有确切定义`type_info`，它的确切定义编译器相关的，但是标准却规定了其实现必需提供如下四种操作（在之后的章节中我会来分析type_info类文件的源码）

| 运算          | 描述                                                  |
| ------------- | ----------------------------------------------------- |
| t1 == t2      | 如果两个对象t1和t2类型相同，则返回true；否则返回false |
| t1 != t2      | 如果两个对象t1和t2类型不同，则返回true；否则返回false |
| t.name()      | 返回类型的C-style字符串，类型名字用系统相关的方法产生 |
| t1.before(t2) | 返回指出t1是否出现在t2之前的bool值                    |

#### Q14 vector定义问题

```c++
vector<int> arr(n + 1);
vector<vector<int> > ans(m,vector<int>(n));
//可以在输入m,n后直接定义此变量
```

#### Q15   除（/)的问题

```c++
double d;
d =static_cast<double>( 3 / 2);
cout << d << endl;
//1

d =static_cast<double> 3 / 2;
cout << d << endl;
//此时会报错，应如上加上括号

d =(double) 3/ 2;
cout << d << endl;
//1.5

d =3*1.0/ 2;
cout << d << endl;
//1.5
```

#### Q16  extern

**extern int a**；//这是变量声明，是告诉编译器应该到该文件外部去找这个文件的定义
//声明是不分配内存的
**int a;**//这是变量定义，变量定义是分配空间的

定义只能有一处，但声明可有多处，这些声明所指，都是定义时分配的内存空间

后面加C如: extern "C" void fun(int a, int b);就是告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非， 

**在实际编程中**，有时程序需要包含多个源文件，若这些文件有共同使用的变量，那么这个变量就遵循“一次定义，多次声明”的形式。即在一个文件中定义，其他文件使用时先进行声明。

例如在文件file1中定义了一个变量：
file1：
int  i =5；
若想在文件file2也使用这个变量，就可以如下：
file2
extern  int  i;  //此时，编译器就知道i是一个已在其他地方定义的变量，会自动在本文件
       //或其他文件中搜寻
i=6;  //声明之后，就可在file2中对变量操作
注意：这种使用对于const变量是个例外。const类型变量默认为当前文件的局部变量，即便在其他文件中声明了也不能使用。要想在其他文件中使用，定义const类型变量时必须在前面显式指出是extern。例如：
file1：
extern  const  int  i=5;
此时就能在其他文件中声明并使用了。具体这方面的原因和头文件的使用有关，这里就不详述了 

#### Q17 语法错误与语义错误

一般的程序错误，粗略一点分的话，可以大致分为语法错误和语义错误。

语法错误可以看作是编码出现了违反C语言规则的错误，一般编译或者链接时，
都会报错的。

而语义错误，也可以叫做逻辑错误，
也就是说你的代码完全符合C语言的规范，不会出现编译/链接的错误，
但是，在逻辑上有错误。

#### Q18 shell打印数组

```shell
#!/bin/bash
# author:菜鸟教程

my_array=(A B "C" D)

echo "第一个元素为: ${my_array[0]}"
echo "第二个元素为: ${my_array[1]}"
echo "第三个元素为: ${my_array[2]}"
echo "第四个元素为: ${my_array[3]}"
```

**获取数组的长度**

获取数组长度的方法与获取字符串长度的方法相同，例如：

```shell
#!/bin/bash
my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo "数组元素个数为: ${#my_array[*]}"
echo "数组元素个数为: ${#my_array[@]}"
```

#### Q19 delete

```c++
int *p=new int[1];
delete p;
p=NULL;//注意这一步
```

#### Q20 gcc调试

GCC采用了分级调试，通过在-g选项后附加数字1、2或3来指定在代码中加入调试信息量。

默认的级别是2（-g2），此时调试信息包括扩展的符号表、行号、局部或外部变量信息。

级别3（- g3）包含级别2中的调试信息和源代码中定义的宏。

级别1（-g1）不包含局部变量和与行号有关的调试信息，只能用于回溯跟踪和堆栈转储之用。

回溯追踪：指的是监视程序在运行过程中函数调用历史。

堆栈转储：则是一种以原始的十六进制格式保存程序执行环境的方法。 

