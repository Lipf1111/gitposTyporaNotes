### 结构体对齐规则

- 计算结构体大小不是元素单纯相加；
- 32位CPU取四个字节比一个字节更高效方便；
- 若每个元素首地址都是4的整数倍，取数据元素就能更高效方便；
- 每个特定平台上编译器都有自己的默认的对齐系数（对齐模数），可通过编译命令来改变这一系数；
- `#pragma pack(n);//n=1,2,4,8,16`,其中n就是你想要指定的系数。
- 一般情况下32位默认4字节对齐。

对齐原因

1. 平台原因（移植原因）
   不是所有的硬件平台都能访问任意地址的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据的，否则抛出硬件异常。
2. 性能原因
   数据结构（尤其是栈），应该尽可能在自然边界上对齐，因为在访问未对齐的内存时，处理器需要访问两次，而对齐的内存处理器只需要访问一次。

对齐规则

1. 第一个成员在与结构体变量偏移量(offset)为0的地址处。
2. 其他成员变量要对齐到对齐数的整数倍的地址处。
   1. 对齐数 = 对齐系数 与 该成员大小的较小值。
   2. `#pragma pack(n);`中的n就是对齐系数。
   3. VS中默认的值为8；linux中的默认值为4。
3. 结构体总大小为最大对齐数（每个成员变量除了第一个成员都有一个对齐数）的整数倍。
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

举例说明对齐原则

```c++
//1.下面的结构体大小分别是多大（假设32位机器）？
struct A {
    char a; //1
    char b; //1
    char c; //1
};
//进行整体对齐，最大类型为1<对齐系数4，按1整体对齐，所以1+1+1=3 
struct B {
    int a;  //4
    char b; //1
    short c;//2
};
//进行整体对齐，最大类型为4=对齐系数4，所以按4整体对齐4 1+2=3<4 对齐4 所以4+4=8 
struct C {
    char b; //1
    int a;  //4
    short c;//2
};
//进行整体对齐，最大类型为4=对齐系数4，所以按4整体对齐 1<4（对齐4） 4=4 2<4(对齐4)  所以4+4+4=12 
#pragma pack(2)
struct D {
    char b; //1
    int a;  //4
    short c;//2
};
//进行整体对齐，最大类型为4>对齐系数n(2)，所以按2整体对齐 1<2（对齐2）4>2(2的倍数) 2=2 所以2+4+2=8 
//答案及解析：3 8 12 8
//2. 有一个如下的结构体：
struct A{
    long a1;
    short a2;
    int a3;
    int *a4;
};
 //  请问在64位编译器下用sizeof(struct A)计算出的大小是多少？
//答案及解析：24
/////////64位编译器下：指针8字节（一定不能忘记），题目不说默认4字节对齐//////
long a1;    //8
short a2;  //2 8+2=10（不是4的倍数）对齐到4的倍数12
int a3;    //4 4+12=16（4的倍数）
int *a4;   //8 8+16=24（4的倍数）
//3.在32位cpu上选择缺省对齐的情况下，有如下结构体定义：
struct A{
    unsigned a : 19;
    unsigned b : 11;
    unsigned c : 4;
    unsigned d : 29;
    char index;
};
/*
则sizeof（struct A）的值为（）
答案及解析16
题目不说，默认4字节对齐
*/
19+11=30<32bit     4
4+29=33>32bit      4+4
1byte=8bit     //    1  对齐到 4
4+4+4+4=16
```

