### 堆与栈

#### 一、数据结构中的堆和栈

##### 1. 栈

是一种**连续储存**的数据结构，具有**后进先出**（Last In First Out,LIFT）的性质。

通常的操作有入栈（压栈），出栈和栈顶元素。想要读取栈中的某个元素，就是将其之间的所有元素出栈才能完成。

##### 2. 堆

是一种**非连续的树形储存数据**结构，每个节点有一个值，整棵树是**经过排序**的。特点是**根结点的值最小（或最大）**，**且根结点的两个子树也是一个堆**。常用来实现优先队列，存取随意。

#### 二、内存中的栈区与堆区

| 栈区                                               | 堆区                                                         |
| -------------------------------------------------- | ------------------------------------------------------------ |
| Stack memory内存空间由**操作系统自动分配和释放。** | Heap Memory内存空间**手动申请和释放**的，Heap Memory内存常用**new关键字来分配**。 |
| Stack Memory内存空间有限。                         | Heap Memor的空间是很大的自由区几乎没有空间限制。             |

#### 三、栈内存与栈溢出

由程序自动向操作系统申请分配以及回收，速度快，使用方便，但程序员无法控制。若分配失败，则提示栈溢出错误。
注意，const局部变量也储存在栈区内，栈区向地址减小的方向增长(一般，有说与系统有关）。 

```c++
#include <iostream>
using namespace std;
int main() {
	int i = 10; //变量i储存在栈区中
	const int i2 = 20;
	int i3 = 30;
	std::cout << &i << std::endl << &i2 << std::endl << &i3 << std::endl;
	return 0;
}
```

```latex
00EFFB60
00EFFB54
00EFFB48
```

#### 四、堆内存与内存泄露

​	程序员向操作系统申请一块内存，当系统收到程序的申请时，会**遍历一个记录空闲内存地址的链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序**。

- 分配的速度较慢，地址不连续，容易碎片化。
- 由程序员申请，同时也必须由程序员负责销毁，否则导致内存泄露。

```c++
#include <iostream>
using namespace std;
int main() {
	int i = 10;               //变量i储存在栈区中
	char pc[] = "hello!";     //pc储存在栈区
	const double cd = 99.2;   //储存在栈区
	static long si = 99;      //si储存在可读写区，专门用来储存全局变量和静态变量的内存
	int* pi = new int(100);   //指针pi指向的内存是在堆区，专门储存程序运行时分配的内存
	cout << &i << endl << &pc << endl << &cd << endl << &si <<endl << pi << endl;
	delete pi;                //需程序员自己释放
	return 0;
}//下边为4次运行结果
```

```latex
0053F850
0053F840
0053F830
00DEC000
0072B3E8
```

```latex
00CEF824
00CEF814
00CEF804
00DEC000
000DFD28
```

```latex
010FFE48
010FFE38
010FFE28
00AFA000
0135E0E0
```

```latex
010FF7B4
010FF7A4
010FF794
00C2C000
012D61F0
```

其中#1与#2是一次生成的程序的两次结果

#3与#4执行时重新生成项目程序的结果。

可知：

- 不论是否重新生成项目，每次执行的在栈区的变量是变化的
- 在可读写取的数据只有重新生成项目的时候的地址才会变化。

### 一个由 c/c++编译过的程序占用的内存分为一下几个部分

1. 栈区 stack ：由编译器自动分配释放，

　　　　　　　　存放函数的参数值，局部变量的值等。

　　　　　　　　这个栈的操作方式类似于数据结构中的栈。

2. 堆区 heap ：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，

　　　　　　　　注意它与数据结构中的堆是两回事，分配方式类似于链表。

3. 全局区（静态区）static ： 全局变量和静态变量的存储是放在一块的。

　　　　　　　　**初始化**的**全局变量**和**静态变量**在一块区域，

　　　　　　　　**未初始化**的全局变量和静态变量又放在相邻的另一块区域中。

　　　　　　　　 程序结束后由系统释放。

4. 文字常量区 ：常量字符串放在这里。

　　　　　　　　程序结束后由系统释放。

5. 程序代码区 ： 存放函数体的2进制代码。

```c++
int a = 0; //全局初始化区 
char *p1; //全局未初始化区 
int main(){ 
	int b;// 栈 
	char s[] = "abc"; //栈 
	char *p2; //栈 
	char *p3 = "123456"; //123456\0";//在常量区，p3在栈上。 
	static int c =0； //全局（静态）初始化区 
	p1 = (char *)malloc(10); 
	p2 = (char *)malloc(20); 
	//分配得来得10和20字节的区域就在堆区。 
	strcpy(p1, "123456"); //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。 
    return 0;
}  
```

### 堆和栈究竟有什么区别

主要的区别由以下几点：
　　(1). 管理方式不同
　　(2). 空间大小不同
　　(3). 能否产生碎片不同
　　(4). 生长方向不同
　　(5). 分配方式不同
　　(6). 分配效率不同
　　管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生`memory leak`。
　　空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：
　　打开工程，依次操作菜单如下`：Project->Setting->Link`，在`Category` 中选中`Output`，然后在`Reserve`中设定堆栈的最大值和`commit`。
　　注意：reserve最小值为4Byte；`commit`是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。
　　碎片问题：对于堆来讲，频繁的`new/delete`势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。
　　生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
　　分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由`alloca`函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
　　分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
　　从这里我们可以看到，堆和栈相比，由于大量`new/delete`的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。
　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。
　　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候`debug`可是相当困难的：）

传送门：

 https://blog.csdn.net/qq_41498261/article/details/83583466 

 https://www.cnblogs.com/yin-jingyu/archive/2012/02/10/2346098.html 

