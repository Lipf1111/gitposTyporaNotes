#### Q1  函数指针

**定义**

函数指针是指向函数的指针变量。

函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。

C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。

**用途：**

调用函数和做函数的参数，比如回调函数。

**示例：**

```c++
char * fun(char * p)  {…}    // 函数fun
char * (*pf)(char * p);       // 函数指针pf
pf = fun;            // 函数指针pf指向函数fun
pf(p);            // 通过函数指针pf调用函数fun
```

#### Q2 析构函数必须是虚函数,C++默认的析构函数不是虚函数

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。

#### Q3 析构函数的作用

析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。

析构函数名也应与类名相同，只是在函数名前面加一个位取反符\~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。

如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。

如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。

**类析构顺序：**1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。

#### Q4  静态函数和虚函数的区别

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

#### Q5 重载和覆盖

重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中

重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写 

#### Q6 strcpy和strlen

strcpy是字符串拷贝函数，原型：

char *strcpy(char* dest, const char *src);

从src逐字节拷贝到dest，直到遇到'\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。
strlen函数是计算字符串长度的函数，返回从开始到'\0'之间的字符个数。

#### Q7 虚函数和多态

多态的实现主要分为静态多态和动态多态

- 静态多态主要是重载，在编译的时候就已经确定；
- 动态多态是用虚函数机制实现的，在运行期间动态绑定。
- 举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。

#### Q8  野指针和悬垂指针

见C++指针辨析

#### Q9  ++i与i++

1. ++i 实现：

```c++
int&  int::operator++(){
    *this +=1;
    return *this;//可以用作左值
}
```

2. i++实现

```c++
const int  int::operator(int){
    int oldValue = *this;
    ++（*this）;
    return oldValue;// 因为返回的是拷贝的临时变量，所以不能是左值
}
```

#### Q10  在main函数执行前先运行

```c++
__attribute((constructor))void before(){
    printf("before main\n");
}
```

#### Q11 有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出20个hello

```c++
for(int i = 0; i < 20; i--)
	cout << "hello" << endl;
```

```c++
for(int i = 0; i + 20; i--)
	cout << "hello" << endl;
```

#### Q12 const修饰成员函数的目的

const修饰的成员函数表明函数调用不会对对象做出任何更改

事实上，如果确认不会对对象做更改，就应该为函数加上const限定

这样无论const对象还是普通对象都可以调用该函数(经测试正确)。

#### Q13  常量

常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。

对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局/静态存储区。

对于字面值常量，常量存放在常量存储区。 

#### Q14 const char * arr = "123"; char * brr = "123"; const char crr[] = "123"; char drr[] = "123";

```c++
const char * arr = "123";
//字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样
char * brr = "123";
//字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改"123"的值
const char crr[] = "123";
//这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区
char drr[] = "123";
//字符串123保存在栈区，可以通过drr去修改
```

#### Q15  字面值常量

称之为字面值是因为只能用它的值来称呼它，称之为常量是因为它的值不能修改。 

`int a = 1234;`

int就是数据类型，a是变量，1234是字面值。

#### Q16  extern“C”

C++调用C函数需要extern C，因为C语言没有函数重载。

#### Q17 C语言是怎么进行函数调用的

每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。

参数压栈顺序：从右到左

#### Q18 C++中拷贝赋值函数的形参能否进行值传递

不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。如此循环，无法完成拷贝，栈也会满。

#### Q19 STL的allocator

STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：

new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容

delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存

为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。

同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。

#### Q20  STL迭代器删除元素

这个主要考察的是迭代器失效的问题。

- 对于序列容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位置，但是erase会返回下一个有效的迭代器；
- 对于关联容器map set来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。
- 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种正确的方法都可以使用。

#### Q21  STL主要组成

容器，迭代器，仿函数算法，分配器，配接器
他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数 。

#### Q22 vector和list的区别，应用

**Vector**

连续存储的容器，动态数组，在**堆**上分配空间

底层实现：数组

两倍容量增长：

vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。

如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。

性能：

访问：O(1)

插入：

- 在最后插入（空间够）：很快
- 在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。
- 在中间插入（空间够）：内存拷贝
- 在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。

删除：

- 在最后删除：很快
- 在中间删除：内存拷贝

适用场景：经常随机访问，且不经常对非尾节点进行插入删除。

**List**

动态链表，在**堆**上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。

底层：双向链表

性能：

访问：随机访问性能很差，只能快速访问头尾节点。

插入：很快，一般是常数开销

删除：很快，一般是常数开销

适用场景：经常插入删除大量数据

**区别：**

1）vector底层实现是数组；list是双向链表。

2）vector支持随机访问，list不支持。

3）vector是顺序内存，list不是。

4）vector在中间节点进行插入删除会导致内存拷贝，list不会。

5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。

6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。

**应用**

vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随机访问，而不在乎插入和删除的效率，使用vector。

list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。

#### Q23指针为何还要迭代器

1、迭代器

Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。

由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。

2、迭代器和指针的区别

迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、*、++、--等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。

3、迭代器产生原因

Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

#### Q24 n个整数的无序数组，找到每个元素后面比它大的第一个数

要求时间复杂度为O(N)

```c++
vector<int> findMax(vector<int>num){
	if(num.size()==0)return num;
	vector<int>res(num.size());
	int i=0;
	stack<int>s;
	while(i<num.size()){
        if(s.empty()||num[s.top()]>=num[i]){
            s.push(i++);
        }else{
            res[s.top()]=num[i];
            s.pop();
        }
	}
	while(!s.empty()){
		res[s.top()]=INT_MAX;
		s.pop();
	}
	for(int i=0; i<res.size(); i++)
		cout<<res[i]<<endl;
	return res;
}
```

#### Q25 STL里resize和reserve的区别

resize()：改变当前容器内含有元素的数量(size())，eg: vector<int>v; v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则3放在了v的末尾，即下标为len，此时容器是size为len+1；

reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存； 

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    vector<int> a;
    a.reserve(100);
    a.resize(50);
    cout<<a.size()<<"  "<<a.capacity()<<endl;//50  100
    a.resize(150);
    cout<<a.size()<<"  "<<a.capacity()<<endl;//150  200
    a.reserve(50);
    cout<<a.size()<<"  "<<a.capacity()<<endl;//150  200
    a.resize(50);
    cout<<a.size()<<"  "<<a.capacity()<<endl;//50  200    
}
```

#### Q26  数据链路层可以提供哪些服务类型 

无确认的无连接服务

有确认的无连接服务

有确认的有连接服务

#### Q27 指针减1

```c++
int main(){
	int a[5] = {1, 2, 3, 4, 5};
	int *ptr = (int*)(&a + 1);
	printf("%d\n", *(a + 1));  //2
    printf("%d\n", *(ptr - 0));//32765
    printf("%d\n", *(ptr - 1));//5
    printf("%d\n", *(ptr - 2));//4
    printf("%d\n", *(ptr - 3));//3
    printf("%d\n", *(ptr - 4));//2
	printf("%d\n", *(ptr - 5));//1
    printf("%d\n", *(ptr - 6));//0
	return 0;
}
/*
(&a+1)先取变量a的地址，并根据a的地址获得下一个与a同类型的相邻地址。根据前面所说的a的类型为int[5]数组。
&a+1=&a+sizeof(5*int)，因此&a+1指向的地址为&a[5](数组a[5]的下一个地址)。
(int*)(&a+1)把这个相邻地址显式类型转换为int类型的地址int*ptr=(int*)(&a+1);
所以ptr指向&a[5]，并且ptr是一个int类型的指针。
*/
```

#### Q28 解引用对比

```c++
#include<iostream>
using namespace std;
void print(char **str){
	++str;
	cout<<*str<<endl;
	//cout<<**str<<endl;输出:w
	//cout<<&(*str)<<endl;输出：0x404068   
}
int main(){
	static char *arr[]={"hello", "world", "c++"};
	char **ptr;
	ptr=arr;
	print(ptr);
	return 0;
}
//输出：world
/*
warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
    8 |   static char *arr[]={"hello", "world", "c++"};
      |                       ^~~~~~~
*/
//*ptr中*为解地址符，不论ptr是一级指针还是二级指针，都是取数据，即*代表从地址解到数据
```

```c++
#include<iostream>
using namespace std;
void print(char *str){
  cout<<*str<<endl;
}
int main(){
  char arr[]={"hello"};
  print(arr);
  return 0;
}
//输出：h
/*
int main(){
    char arr[]="hello";
    char *ptr=(char *)(arr+1);
    print(ptr);
    return 0;
}
//输出：e
*/
```

#### Q29 虚继承

```c++
#include "bits_stdc++.h"
using namespace std;
class Person {
public:
	Person() { name = new char[16]; cout << "Person构造" << endl; }
	virtual  ~Person() { delete[]name; cout << "Person析构" << endl; }
private:
	char* name;
};
class Teacher :virtual public Person {
public:
	Teacher() { cout << "Teacher构造" << endl; }
	~Teacher() { cout << "Teacher析构" << endl; }
};
class Student :virtual public Person {
public:
	Student() { cout << "Student构造" << endl; }
	~Student() { cout << "Student析构" << endl; }
};
class TS : public Teacher, public Student {
public:
	TS() { cout << "TS构造" << endl; }
	~TS() { cout << "TS析构" << endl; }
};
int main(int argc, char* argv[]) {
	Person* p = new TS();
	delete p;
	return 0;
}
```

```out
Person构造
Teacher构造
Student构造
TS构造
TS析构
Student析构
Teacher析构
Person析构
但是当我们把Person类中析构前面的virtual去掉之后的运行结果为：
Person构造
Teacher构造
Student构造
TS构造
Person析构
程序崩溃 //该是因为name指针的两次析构问题
```

虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类。实现的代码如下：

```c++
class A
class B1:public virtual A;
class B2:public virtual A;
class D:public B1,public B2;
```

虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。

#### Q30 虚析构

```c++
#include ...
using namespace std;
class Person {
public:
	Person() { cout << "Person构造" << endl; }
	~Person() { cout << "Person析构" << endl; }
};
class Teacher : virtual public Person {
public:
	Teacher() { cout << "Teacher构造" << endl; }
	~Teacher() { cout << "Teacher析构" << endl; }
};
class Student : virtual public Person {
public:
	Student() { cout << "Student构造" << endl; }
	~Student() { cout << "Student析构" << endl; }
};
class TS : public Teacher, public Student {
public:
	TS() { cout << "TS构造" << endl; }
	~TS() { cout << "TS析构" << endl; }
};
int main(int argc, char* argv[]) {
	TS ts;
	return 0;
}
```

```out
Person构造
Teacher构造
Student构造
TS构造
TS析构
Student析构
Teacher析构
Person析构
当Teacher类和Student类没有虚继承Person类的时候，也就是把virtual去掉时候终端输出的结果为：
Person构造
Teacher构造
Person构造
Student构造
TS构造
TS析构
Student析构
Person析构
Teacher析构
Person析构 
```

#### Q31 虚函数

```c++
#include ...
using namespace std;
class A{
public:
     virtual  void  display(){  cout<<"A"<<endl; }
};
class B :  public A{
public:
     void  display(){ cout<<"B"<<endl; }
};
void doDisplay(A *p){
    p->display();
    delete p;
}
int main(int argc,char* argv[]){
    doDisplay(new B());
    return 0;
}
//输出：B
//virtual注释掉的话输出为A
//基类指针指向派生类对象是安全的，若是含有虚函数，则会查询虚函数表，指向基类的函数
```

### Q32 <<优先级

```c++
#include <iostream>
using namespace std;
void max(int i, int j) {
    cout << (i>j) ? i : j;
}
int main() {
    int m = 016, n = 18;
    max(m, n);
	return 0;
}
```

 应该是考察优先级的。

```c++
cout << (i>j) ? i : j;// <<的优先级高于三目运算符，因为前为（i>j）为假，输出0
cout << ((i>j) ? i : j);// 此时输出18
cout << i>j ? i : j;// 这样还会报错，说没有匹配的运算符 > 
```

| 优先级 | 运算符 | 名称或含义       | 使用形式                  | 结合方向 | 说明             |
| ------ | ------ | ---------------- | ------------------------- | -------- | ---------------- |
| 1      | []     | 数组下标         | 数组名[常量表达式]        | 左到右   |                  |
|        | ()     | 圆括号           | （表达式）/函数名(形参表) |          |                  |
|        | .      | 成员选择（对象） | 对象.成员名               |          |                  |
|        | ->     | 成员选择（指针） | 对象指针->成员名          |          |                  |
| 2      | -      | 负号运算符       | -表达式                   | 右到左   | 单目运算符       |
|        | (类型) | 强制类型转换     | (数据类型)表达式          |          |                  |
|        | ++     | 自增运算符       | ++变量名/变量名++         |          | 单目运算符       |
|        | --     | 自减运算符       | --变量名/变量名--         |          | 单目运算符       |
|        | *      | 取值运算符       | *指针变量                 |          | 单目运算符       |
|        | &      | 取地址运算符     | &变量名                   |          | 单目运算符       |
|        | !      | 逻辑非运算符     | !表达式                   |          | 单目运算符       |
|        | ~      | 按位取反运算符   | ~表达式                   |          | 单目运算符       |
|        | sizeof | 长度运算符       | sizeof(表达式)            |          |                  |
| 3      | /      | 除               | 表达式/表达式             | 左到右   | 双目运算符       |
|        | *      | 乘               | 表达式*表达式             |          | 双目运算符       |
|        | %      | 余数（取模）     | 整型表达式/整型表达式     |          | 双目运算符       |
| 4      | +      | 加               | 表达式+表达式             | 左到右   | 双目运算符       |
|        | -      | 减               | 表达式-表达式             |          | 双目运算符       |
| 5      | <<     | 左移             | 变量<<表达式              | 左到右   | 双目运算符       |
|        | >>     | 右移             | 变量>>表达式              |          | 双目运算符       |
| 6      | >      | 大于             | 表达式>表达式             | 左到右   | 双目运算符       |
|        | >=     | 大于等于         | 表达式>=表达式            |          | 双目运算符       |
|        | <      | 小于             | 表达式<表达式             |          | 双目运算符       |
|        | <=     | 小于等于         | 表达式<=表达式            |          | 双目运算符       |
| 7      | ==     | 等于             | 表达式==表达式            | 左到右   | 双目运算符       |
|        | !=     | 不等于           | 表达式!= 表达式           |          | 双目运算符       |
| 8      | &      | 按位与           | 表达式&表达式             | 左到右   | 双目运算符       |
| 9      | ^      | 按位异或         | 表达式^表达式             | 左到右   | 双目运算符       |
| 10     | \|     | 按位或           | 表达式\|表达式            | 左到右   | 双目运算符       |
| 11     | &&     | 逻辑与           | 表达式&&表达式            | 左到右   | 双目运算符       |
| 12     | \|\|   | 逻辑或           | 表达式\|\|表达式          | 左到右   | 双目运算符       |
| 13     | ?:     | 条件运算符       | 表达式1? 表达式2: 表达式3 | 右到左   | 三目运算符       |
| 14     | =      | 赋值运算符       | 变量=表达式               | 右到左   |                  |
|        | /=     | 除后赋值         | 变量/=表达式              |          |                  |
|        | *=     | 乘后赋值         | 变量*=表达式              |          |                  |
|        | %=     | 取模后赋值       | 变量%=表达式              |          |                  |
|        | +=     | 加后赋值         | 变量+=表达式              |          |                  |
|        | -=     | 减后赋值         | 变量-=表达式              |          |                  |
|        | <<=    | 左移后赋值       | 变量<<=表达式             |          |                  |
|        | >>=    | 右移后赋值       | 变量>>=表达式             |          |                  |
|        | &=     | 按位与后赋值     | 变量&=表达式              |          |                  |
|        | ^=     | 按位异或后赋值   | 变量^=表达式              |          |                  |
|        | \|=    | 按位或后赋值     | 变量\|=表达式             |          |                  |
| 15     | ,      | 逗号运算符       | 表达式,表达式,…           | 左到右   | 从左向右顺序运算 |

同一优先级的运算符，运算次序由结合方向所决定。 

**括号成员第一;**     //括号运算符\[]() 成员运算符.  ->

**全体单目第二;**     //所有的单目运算符比如++、 --、 +(正)、 -(负) 、指针运算*、&乘除余三,加减四;  //这个"余"是指取余运算即%

**移位五，关系六;**   //移位运算符：<< >> ，关系：> < >= <= 等

**等于(与)不等排第七;**   //即== 和!=

**位与异或和位或;**   //这几个都是位运算: 位与(&)异或(^)位或(|)   

**"三分天下"八九十;**  

逻辑或跟与;       //逻辑运算符:|| 和 &&

十二和十一;       //注意顺序:优先级(||)  底于 优先级(&&) 

条件高于赋值,     //三目运算符优先级排到13 位只比赋值运算符和","高

逗号运算级最低!   //逗号运算符优先级最低 