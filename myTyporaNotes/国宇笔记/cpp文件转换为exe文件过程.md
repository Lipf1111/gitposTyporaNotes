下面来简述一下C++**.cpp**文件转换为**.exe**文件的过程。

我们知道当我们用C++编译器编辑一个文件时，这个文件就是一个扩展名为**.c**或**.cpp**文件，而当我们进行编译运行之后，编译器会为我们自动生成一个扩展名为**.exe**文件。那么这个过程是怎样的呢？接下来我们来解析这样一个过程。

首先我们来看图解。

![img](.\Pic\20180402225920837.jpg)

过程解析如下：

（一）预处理阶段。首先我们会对我们编辑得到的源代码（即扩展名为.**c/.cpp**文件）通过预处理器进行预处理，这一部分是由我们的编译器帮我们完成的。预处理器做的事情就是将原始源文件中的所有预处理器指令替换为暗示指令的实际库代码。那么什么是预处理指令呢？实际上这些是我们在代码很常见的，如**#include**和**#define**指令。之后，生成的文件基本上被取代并获得扩展名为.**i**文件。
		• 处理所有的注释，以空格代替
		•将所有的#define删除，并且展开所有的宏定义
		•处理条件编译指令#if, #ifdef, #elif, #else, #endif
		•处理#include，展开被包含的文件
		•保留编译器需要使用的#pragma指令 

（二）编译器编译阶段。接下来是编译器的处理阶段，这个阶段是把高级语言翻译成低级语言的过程，也负责检查源代码的语法/语义。若发现无误，则会将文件转换为扩展名为.**s**的文件，即我们所知的汇编代码。

​		•对预处理文件进行一系列词法分析，语法分析和语义分析
​		•词法分析主要分析关键字，标示符，立即数等是否合法
​		•语法分析主要分析表达式是否遵循语法规则
​		•语义分析在语法分析的基础上进一步分析表达式是否合法
​		•分析结束后进行代码优化生成相应的汇编代码文件 

（三）目标文件转换阶段。得到汇编文件之后，要对其进行转换，即该过程是将汇编级语言转换为机器级语言（一般为二进制格式），此时生成的文件就是我们的目标文件，扩展名为**.o**或**.obj**。
​		•汇编器将汇编代码转变为机器可以执行的指令

**静态链接在编译期完成，动态链接在运行期完成**

（四）链接阶段。C++语言支持分离式编译（这里指的编译是指上面（一）至（三）阶段）机制的，该机制允许将程序分割为若干个文件，每个文件可独立编译。那么多个已编译的文件如何合并呢？答案就是在此阶段。该阶段通过链接器将一个或多个目标文件合并到一个可执行文件，即将扩展名为**.obj** / **.o**文件转换为扩展名为**.exe**文件。

以上的四个阶段就是**.cpp**文件转换为**.exe**文件的过程。

注：我们平常所说的“编译”是一个整体，即包括预处理，编译和汇编三个阶段。它在这些步骤中基本上将高级语言转换为机器级语言，并生成单个二进制对象文件。若编译（但不链接）三个单独的文件，则将创建三个作为输出的目标文件。







二、宏定义

宏表达式中不能出现递归定义；

宏定义之后在程序的任何地方都可以引用该宏，如果不需要在后续代码中利用该宏可通过#undef

内置宏：

​        _\_FILE\_\_ 被编译的文件名；

​        _\_LINE\_\_ 当前行号；

​        _\_DATE\_\_ 编译时的日期；Jan 31 2012

​       _\_TIME\_\_ 编译时的时间；17:01:01

​       _\_STDC\_\_编译器是否遵循标准C规范

三：条件编译：#if…#else…#endif

四：#error和#line

\#error用于生成一个编译错误消息，并停止编译，#warning用于生成编译警告，但不会停止编译，例#error message

\#line用于强制指定新的行号和编译文件名，并对源程序的代码重新编号，用法#line number filename(filename可省略)
    其本质是重定义__LINE__和__FILE__

**#pragma**，用法#pragma parameter

\#pragma是编译器指示字，用于指示编译器完成一些特定的动作
\#pragma所定义的很多指示字是编译器和操作系统特有的
\#pragma在不同的编译器间是不可移植的

​        预处理器将忽略它不认识的#pragma指令
​       两个不同的编译器可能以两种不同的方式解释同一条#pragma指令

**内存对齐：**

不同类型的数据在内存中按照一定的规则排列；而不是顺序的一个接一个的排放，这就是对齐。
CPU对内存的读取不是连续的，而是分成块读取的，块的大小只能是1、2、4、8、16字节，当读取操作的数据未对齐，则需要两次总线周期来访问内存，因此性能会大打折扣；某些硬件平台只能从规定的地址处取某些特定类型的数据，否则抛出硬件异常
struct占用的内存大小
第一个成员起始于0偏移处

**#和##运算**

\#运算符用于在预编译期将宏参数转换为字符串

```c++
#include <stdio.h> 
#define CALL(f, p) (printf("Call function %s\n", #f), f(p))
int square(int n){
    return n * n;
}
int f(int x){
    return x;
}
int main(){
    printf("1. %d\n", CALL(square, 4));
    printf("2. %d\n", CALL(f, 10));
    return 0;
}
```


\##运算符用于在预编译期粘连两个符号

```c++
#include <stdio.h>
#define NAME(n) name##n
int main(){
    int NAME(1);
    int NAME(2);
    
    NAME(1) = 1;
    NAME(2) = 2;
    
    printf("%d\n", NAME(1));
    printf("%d\n", NAME(2));
     
    return 0;
}
```

