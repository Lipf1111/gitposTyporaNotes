#### Q1 合并数组

**默认为升序**

```c++
class Solution {
public:
    void merge(int A[], int m, int B[], int n) {
        int aPtr=m-1;
        int bPtr=n-1;
        int ptr=m+n-1;
        while(aPtr>=0&& bPtr>=0){
            if(A[aPtr]>B[bPtr])
                A[ptr--]=A[aPtr--];
            else
                A[ptr--]=B[bPtr--];
        }
        if(aPtr==-1)
            while(A[ptr--]=B[bPtr--]);
    }
};
```

#### Q2 构造函数不能声明为虚函数

构造函数不能声明为虚函数，析构函数可以声明为虚函数，而且有时是必须声明为虚函数。

不建议在构造函数和析构函数里面调用虚函数。

构造函数不能声明为虚函数的原因是:

1. 构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类。无法确定。
2. 虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。虚函数的意思就是开启动态绑定，程序会根据对象的动态类型来选择要调用的方法。然而在构造函数运行的时候，这个对象的动态类型还不完整，没有办法确定它到底是什么类型，故构造函数不能动态绑定。

#### Q3 move()函数

move作用主要可以将一个左值转换成右值引用，从而可以调用C++11右值引用的拷贝构造函数，在对象拷贝的时候，在运行时，它们不会产生一行代码原先的对象也会清空， 可以减少资源创建和释放。作为可以归纳为以下几点：

1. std::move函数可以以非常简单的方式将左值引用转换为右值引用。
2. 通过std::move，可以避免不必要的拷贝操作。
3. std::move是为性能而生。
4. std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝。

​		两个地址是独立的，move操作实际上是系统将这一块地址属于哪一个地址的登记改一下，实际上这一块内存根本没有发生任何变化。

#### Q4  define MAX 出错

```cpp
#define MAX 1000   
int n2[MAX] = {0};
//显示无法识别的标识符
//或者显示  此宏周围的操作可能会失败，请考虑将其添加到提示文件
//可根据VS提示修改为下式解决
constexpr auto MAX = 1000;
int n2[MAX] = { 0 };
//也可修改文件的编码格式，原来显示unicode带签名，换成GB2312解决
```

#### Q5 数组长度

```c
int solve(int* a, int aLen) ;
int solve(int a[], int aLen) ;
//像这种为指针的，需遍历的一般要给出长度，不然strlen(a)求其长度
//cout << sizeof(a) / sizeof(a[0]);报C6384	用另一个值除指针的 sizeof 值。	
```

```c++
int a[] = {1,2,3,4,5};
cout<< sizeof(a) / sizeof(a[0]);//5
//此时可以此方法求取数组长度，此时a是int型数组变量
//但是上一代码中传入函数的为指针，结果恒等于1
```

#### Q6 同样的一段程序计算耗时，为什么每次结果都不一样

1. 你的程序不是运行一个纯净的系统上。可能有操作系统、安全软件、绘图界面、后台服务在运行，他们毫无疑问会抢占你的资源。
2. 假如把你的程序移植到一个纯净的系统上，不存在目标程序之外的其它无关软件。你的CPU会不会处在睿频模式或者节能模式或者睡眠模式？Cache是不是都被清空了？
3. 假如你禁用CPU的所有高级功能，并保证每次运行前清空高速缓存。你的DRAM存储器会不会恰好要刷新？你的机械硬盘是不是恰好要寻道？你的固态硬盘是不是恰好碰到坏块要纠错？

#### Q7 substr()和substring()

**substr（C++语言函数）**

`basic_string substr(size_type _Off = 0,size_type _Count = npos) const;`

substr是C++语言函数，主要功能是复制子字符串，要求从指定位置开始，并具有指定的长度。如果没有指定长度Count或Count+_Off超出了源字符串的长度，则子字符串将延续到源字符串的结尾。

参数

pos

所需的子字符串的起始位置。字符串中第一个字符的索引为 0,默认值为0.

count

子串的长度

返回值

一个子字符串，从其指定的位置开始

substring(start, end)

start：指明子字符串的起始位置，该索引从 0 开始起算。

end：指明子字符串的结束位置，该索引从 0 开始起算。

**substring** 方法将返回一个包含从 *start* 到最后（不包含 *end* ）的子字符串的字符串。

#### Q8 清屏函数

system("cls")；#include<stdlib.h>头文件

clrscr(); #include<conio.h>头文件

#### Q9判断是否是回文数字

```c++
bool isPalindrome(int x) {
    if(x<0)
        return false;
    int temp=0;
    while(x > temp){
        temp=temp*10+x%10;
        x/=10;
    }
    return temp==x || temp/10==x;
}
```

#### Q10 对同一类进行两次析构的问题

对于同一个类进行两次析构一般情况不会出现问题，但是当在析构函数中调用了delete对于类中的成员变量进行销毁则会出现问题，如果进行两次析构函数，则会对同一个变量进行两次销毁，则第二次销毁就会出现问题，会出现**_BLOCK_TYPE_IS_VALID(pHead->nBlockUse**的问题。

出现这个问题的原因有：

1.内存泄漏：所以当程序退出是，系统会收回分配的内存，于是调析构函数，由于内存已被错误地释放，于是就会出现“Debug Assertion Failed”的错误。

2.这个assert说明什么问题，说明有一块内存在被释放的时候，它的头部里面的信息已经被改掉了，和预期的不一样，内存分配的程序往往在被分配出的内存块头部放上一些校验信息，这个信息内存的用户是不知道也不应该修改的。这样，在内存被释放的时候，内存分配程序就可以校验出这个头部信息是否被改过了，若被改过，就说明发生了内存的corruption。

这种corruption有两种可能：

1.说明有人在内存越界写东西；

2.这块内存已经被释放了，又被重复释放了一次。

 3.pHead->nBlockUse已经是空指针了。或者它指向的东西已经消失了。

下列是一个例子：

```c++
class A{
public:
	A(){
		use = new int[5];
	}
	~A(){
		delete[] use;
	}
private:
	int *use;
};
class B{
public:
	B(A &obj) :a(obj){}
	~B(){}
private:
	A a;
};
int main(){
    A a;
    B b(a);
    return 0;
}
```

这个例子会发生错误，因为在B进行析构的时候会对成员A进行析构，会销毁a的变量use，之后会再对A进行一次析构，这样同一个类对象a就进行了两次析构，要消除这种错误，只有对B的成员变量a定义为A的引用，如下面的例子所所示。

```cpp
class A{
public:
    A()	{
        use = new int[5];
    }
    ~A(){
        delete[] use;
    }
private:
    int *use;
};
class B{
public:
    B(A &obj) :a(obj)	{ 	}
    ~B()	{}
private:
    A& a;
};
```

#### Q11

x & (−x) 可以获得 xx 的二进制表示中的最低位的 1 的位置；

x\&(x-1)可以将 xx 的二进制表示中的最低位的 1置成 0。

#### Q12 进程与线程的区别

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线

3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信

号等)，某进程内的线程在其他进程不可见；

4. 调度和切换：线程上下文切换比进程上下文切换要快得多

#### Q13 进程间通信方式

1. 管道：速度慢，容量有限，只有父子进程能通讯   

2. FIFO：任何进程间都能通讯，但速度慢   

3. 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   

4. 信号量：不能传递复杂消息，只能用来同步   

5. 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

#### Q14 结构体初始化注意事项

```c++
struct dListNode{
    int val;
    struct dListNode *pre;
    struct dListNode *next;
    dListNode(int x):val(x),pre(nullptr),next(nullptr){}//#1
};
//#1 前不能为 struct dListNode(int x)...,否则会报错：没有完整的对象类型
```

#### Q15 类的成员变量为什么要设为私有的

类的成员变量为什么要设为私有的，然后设置get和set函数。

因为对于使用这个类的人你不需要了解内部实现，封装隐藏起来 

把可以让别人访问和修改的，以接口的形式公开，接口的好处在于，别人依赖你的接口，而不是依赖你具体的实现，那么你修改了这个接口的实现，别人那边不需要改，举个例子。

你的类中有一个方法int getCount(){return this->count;};
别人某个地方使用了你这个getCount, 然后有一天你改了实现例如{return this->count * 2;};别人的代码不需要改就可以编译通过。 

#### Q16 原子性

 指事务的不可分割性，一个事务的所有操作要么不间断地全部被执行，要么一个也没有执行。 