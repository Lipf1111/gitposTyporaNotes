### 算法的复杂度分析

#### 时间复杂度

​		最直接的评价算法时间复杂度的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。

##### 缺点

- 但是这种方式非常容易受运行环境的影响，**在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大**
- **对测试时使用的数据规模也有很大关系**
- 另，我们一般是在设计算法的时候就要考虑时间复杂度，此时还不能完整的通过运行来判断

因此，我们用一种通用的方法**定性分析**算法的时间复杂度：**「 大O符号表示法 」，即 T(n) = O(f(n))** 

```c++
for(i=1; i<=n; ++i){
   j = i;
   j++;
}
```

​		在大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度**。 

​		我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) =  (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) =  O(n) 

​		为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示**代码执行时间的增长变化趋势的**。

​		所以上面的例子中，如果n无限大的时候，T(n) =  time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) =  O(n) 就可以了。

常见的时间复杂度量级有：

- 常数阶O(1)

- 对数阶O(logN)

  ​	一般以具有二分法思想的算法。

- 线性阶O(n)

- 线性对数阶O(nlogN)

  ​	一次循环内的二分法。

- 平方阶O(n²)

- 立方阶O(n³)

- K次方阶O(n^k)

- 指数阶(2^n)

Ο(1)＜Ο(log~2~n)＜Ο(n)＜Ο(nlog~2~n)＜Ο(n^2^)＜Ο(n^3^)＜…＜Ο(2^n^)＜Ο(n!)

​	Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log~2~n)、Ο(n)、 Ο(nlog~2~n)、Ο(n^2^)和Ο(n^3^)称为**多项式时间**，而Ο(2^n^)和Ο(n!)称为**指数时间**。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为**P（Polynomial,多项式）**类问题，而把后者（即指数时间复杂度的算法）称为**NP（Non-Deterministic Polynomial, 非确定多项式）**问题。 

 ![img](.\Pic\20130920172327687.png) 

#### 空间复杂度 （Space Complexity)）

 算法的存储量包括:

- 程序本身所占空间
- 输入数据所占空间；
- 辅助变量所占空间

​	输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的辅助变量所占额外空间。

  空间复杂度是对一个算法在运行过程中**<u>临时</u>占用的存储空间大小**的量度，一般也作为问题规模n的函数，以数量级形式给出，记作：
    S(n) = O(g(n)) 

​    不随问题规模的大小而改变，我们称这种算法是“**就地**\"进行的 

​	如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1) 

```c++
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

​		代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1) 

```c++
int[] m = new int[n]
for(i=1; i<=n; ++i){
   j = i;
   j++;
}
```

​		这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n) 

#### 几道计算时间复杂度和空间复杂度的经典习题

> 例1：

```c++
void bubbleSort(int[] array) {
   for (int end = array.length; end > 0; end--) 	{
       boolean sorted = true;
       for (int i = 1; i < end; i++) {
           if (array[i -1] > array[i]) {
               Swap(array, i - 1, i);
               sorted = false;
           }
       }
       if (sorted == true) {
           break;
       }
   }
}
```

 时间复杂度为O(N^2^),空间复杂度为O(1）

>  例2：

```c++
int binarySearch(int[] array, int value) {
   int begin = 0;
   int end = array.length - 1;
   while (begin <= end) {
       int mid = begin + ((end-begin) / 2);
       if (array[mid] < value)
           begin = mid + 1;
       else if (array[mid] > value)
           end = mid - 1;
       else
           return mid;
   }
   return -1;
}
```

 时间复杂度O(log~2~N)，空间复杂度O(1) 

> 例3：

```c++
long factorial(int N) {
	return N < 2 ? N : factorial(N-1) * N;
    //[fækˈtɔːriəl]阶乘
}
```

 时间复杂度O(N)，空间复杂度O(N) 

> 例4：

```c++
int fibonacci(int N) {
	return N < 2 ? N : fibonacci(N-1)+fibonacci(N-2);
}
```

 时间复杂度O(2^N^)，空间复杂度O(N) 

> 另注：

vs2019下的一个例子：用于分析循环中定义变量的地址变化情况。

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
	vector<int*> res, res2;
	for (int i=0; i < 10; i++) {
		int c = i;
		int* d = new int(i);
		res.push_back(&c);
		res2.push_back(d);
	}
	for (int i=0; i < 10; i++) 
		cout << res[i] << ":"<< res2[i] << endl;
	return 0;
}
```

```latex
010FFC34---0149BAD8
010FFC34---01497190
010FFC34---01497160
010FFC34---0149E050
010FFC34---01495B90
010FFC34---01495BC0
010FFC34---01495BF0
010FFC34---01495AA0
010FFC34---01490530
010FFC34---01490560
```

