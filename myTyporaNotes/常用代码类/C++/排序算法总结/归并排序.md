# 算法思想

- 一个数组，左右分成两半，然后归并

**<font color=red>代码1</font>**

```c++
#include <iostream>
#include <string>
using namespace std;

void printfArr(int* arr,int len) {
	for (int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
}

int main() {
	int arr[] = { 1,3,6,7,2,4,8 };
	int len = sizeof(arr) / sizeof(arr[0]);
	//将数组分成两半
	int mid = len >> 1;
	//前一半用i指向，后一半用j指向
	int i = 0;
	int j = mid + 1;

	//创建一个等长的新数组
	int* temp = new int[len];
	//k指向 temp数组首地址
	int k = 0;

	while (i <= mid && j < len) {
        //归并排序是稳定的，所以这里要加=号
		if (arr[i] <= arr[j])
		{
			temp[k] = arr[i];
			i++;
		}
		else {
			temp[k] = arr[j];
			j++;
		}
		k++;
	}

	while (i <= mid) temp[k++] = arr[i++];
	while (j < len) temp[k++] = arr[j++];
	printfArr(temp, len);
	return 0;
}
```

**<font color=red>代码2</font>**

```c++
#include <iostream>
#include <string>
using namespace std;

void printfArr(int* arr,int len) {
	for (int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
}

void mergeSort(int* arr,int leftPtr,int rightPtr,int rightBound) {
	//将数组分成两半
	int mid = rightPtr -1;
	//创建一个等长的新数组
	int* temp = new int[rightBound - leftPtr + 1]();
	//前一半用i指向，后一半用j指向
	int i = leftPtr;
	int j = rightPtr;
	//k指向 temp数组首地址
	int k = 0;

	while (i <= mid && j <= rightBound) {
		temp[k++] = arr[i] <= arr[j] ? arr[i++] : arr[j++];
	}

	while (i <= mid) 
		temp[k++] = arr[i++];
	while (j <= rightBound)
		temp[k++] = arr[j++];

	for (int m = 0; m < (rightBound - leftPtr + 1); m++)
	{
		arr[m+leftPtr] = temp[m];
	}
}

void sort(int *arr,int left,int right) {
	if (left == right) return;
	//归并排序，先分成两半
	//int mid = (left + right) / 2;
	int mid = left + (right - left) / 2;//写法一样 这样的话可以省得数字多时越界
	//左边排序
	sort(arr, left, mid);
	//右边排序
	sort(arr,  mid+1, right);
	//归并
	mergeSort(arr, left, mid+1, right);
}

int main() {
	int arr[] = { 1,3,6,7,2,4,8 };
	int len = sizeof(arr) / sizeof(arr[0]);
	sort(arr,  0, len - 1);
	printfArr(arr, len);
	return 0;
}
```

